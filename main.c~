/*********************************************************************************
*                                                                                
*   File Name:   main.c                                                                
*                                                                                
*   Content:     Contains main loop for demo code                                                                
**********************************************************************************                                                                               
*   Copyright (c) 2002 Mitsubishi Electric and Electronics USA, Inc.             *    
*   All rights reserved                                                          *
**********************************************************************************
*   The software supplied by Mitsubishi Electric and Electronics USA, Inc.       *
*   is intended and supplied for use on Mitsubishi Electric  products.           *
*   This software is owned by Mitsubishi Electric and Electronics USA, Inc.      *
*   or Mitsubishi Electric Corporation and is protected under applicable         *
*   copyright laws. All rights are reserved.                                     *                                                                                *
*   THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED   *
*   OR STATUTORY, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF             *
*   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. *
*   MITSUBISHI ELECTRIC AND ELECTRONICS USA, INC. AND MITSUBISHI ELECTRIC        *
*   CORPORATION RESERVE THE RIGHT, WITHOUT NOTICE, TO MAKE CHANGES TO THIS       *
*   SOFTWARE. NEITHER MITSUBISHI ELECTRIC AND ELECTRONICS USA, INC. NOR          *
*   MITSUBISHI ELECTRIC CORPORATION SHALL, IN ANY CIRCUMSTANCES, BE LIABLE       *
*   FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES FOR ANY REASON WHATSOEVER  *
*   ARISING OUT OF THE USE OR APPLICATION OF THIS SOFTWARE.                      *
*                                                                                *
*================================================================================*
*   $Log: main.c,v $
*   Revision 1.2  2002-06-07 14:00:18-04  bembry
*   Fixed flicker problem.  Chang Temp conversion equation fixes problem at "0" crossover point.
*
*================================================================================*/

#include "10sk.h"		/* SFR register definition */
#include "rtc.h"        /* real time clock function. */
#include "convert_temp.h"

void display_task(void);
void mode_task(void);
void temp_message_task(void);
void display_welcome_message(void);
void display_time(char ln);
void AD_sample_task(void);
#pragma INTERRUPT ad_intr_handler
void ad_intr_handler(void);

unsigned char ad_flag;
unsigned char sys_mode;
enum SYSTEM_MODES{ SET_HR = 0, SET_MIN, DIS_TIME_TEMP, TEMP_MESSAGE,SET_HEADING};
char cur_hour, cur_min, cur_sec, last_sec;
char key;
const char message[7][9] = {
{"SET HOUR"},
{"SET MIN "},
{"MAIN OSC"},
{"RUNNING "},
{"STOPPED "},
{"        "},
{"SET DEG "}};

const char num[15] = {'0','1','2','3','4','5','6','7','8','9',':','F','C',' ','.'};
const char deg_S[8] = {0x08,0x14,0x08,0x00,0x00,0x00,0x00,0x00};
unsigned char clock_mode_change;    // set according to mode of clock.              
unsigned char temp_mess_dis_timer;  // temp display timer. 
unsigned char current_sys_mode;     // return to mode after time out. 
unsigned char temp_display_mode;    // allows setting of temp display mode. 
unsigned char clock_fault_reset;    
unsigned char init_osc_det; 
unsigned char clock_mode_charnge; 
unsigned int ad_value, avg_ad_value;                 //ad values.    
float temperature;


/*****************************************************************************
Name:		main
Parameters:	None
Returns:	None 
Description: Initializes the system and then responds to user actions.
*****************************************************************************/
void main()
{

    init_BSP();     // Intialize Board Support Package.
    disp_ctrlw(0x78); // write CGRAM address pointer 
    for (key=0; key <8; key++)   // degree symbole is 0x08 hex.  
        disp_dataw(deg_S[key]);  // Write degree symbole to LCD's CGRAM area.       

    sys_mode =  SET_HR;
    cur_hour = 0; cur_min = 0; cur_sec = 0; last_sec = 0;   // Intialize clock variables
    /*** enable 32K clcok for real time clock.****/
    prc0 = 1;       // Enable writes to clock control register.
    cm03 = 1;       // Xcin, Xcout high drive mode  
    cm04 = 1;       // Enable Xcin, Xcout ports 
    cm2 = 0x03;      // Enable OSC STOPPED detection 
    prc0 = 0;       // Disable writes to clock control register. 
    /*** Intialize AD input.  *********************************/
	adcon0 = 0x97;        // Fad/2, AN11, Single Shot, Port 1 selected. 
    adcon1 = 0x28; // Vref connected, 10bit mode.
    adcon2 = 0x01; // With Sample and hold.
    DISABLE_INTS
    adic = 0x05; 
    ENABLE_INTS
    adst = 1;      // start first conversion.    
    /**  End of AD intialization ******************************/
    init_osc_det = 0;
    clock_fault_reset = 0;
    temp_mess_dis_timer = 0;
    clock_mode_charnge = 0;
    display_welcome_message();      
    addTask(display_task, 30, 1);
    addTask(mode_task, 20, 2);
    addTask(temp_message_task, 35, 0);
    addTask(AD_sample_task, 5, 3);
    Run_RR_Scheduler();
}
/*****************************************************************************
Name:         display_task  
Parameters:                     
Returns:        
Description:  Display data on LCD screen dependent on mode of operation.   

*****************************************************************************/
void display_task(void)
{
static unsigned int dis_temp;
static unsigned int result;
static char Flag_t100;

    switch(sys_mode){
        case SET_HR:
            display(0, message[0]);
            display_time(1);
            break;
        case SET_MIN:
            display(0, message[1]);
            display_time(1);
            break;
        case TEMP_MESSAGE:
            break;
	case SET_HEADING:
            display(0, message[6]);
            display(1, strHeading);
		break;
        case DIS_TIME_TEMP:
        default:
            get_time(&cur_hour, &cur_min, &cur_sec);
            display_time(0);
            if(cm23 == 0){
                temperature = AD_input_to_deg_F(avg_ad_value);
                if(temp_display_mode) // degree C.
                    temperature =  Convert_F_to_C(temperature);
                }
            if((temperature >= 0) && (cm23 == 0) && (temperature < 126) && (avg_ad_value < 9500)){
                Flag_t100 = 0;
                dis_temp = (unsigned int)(temperature * 10);
                //display(LINE2, message[5]);
                disp_ctrlw(LCD_HOME_L2);
                result = dis_temp / 1000;
                if(result != 0){
                    Flag_t100 = 1;  
                    disp_dataw(num[result]);    // Print temp values 100 and above.
                    dis_temp = dis_temp - (result * 1000);
                    }
                else disp_dataw(num[13]);        // if temp < 100 print a space.
                result = dis_temp / 100;
                if((result != 0)||(Flag_t100 == 1)) {  
                    disp_dataw(num[result]);    // Start printing temp values 10 to 99 and above.
                    dis_temp =  dis_temp - (result * 100); 
                    }
                else disp_dataw(num[13]);        // if temp < 10 print a space.
                result = dis_temp / 10;
                disp_dataw(num[result]);    // Start printing temp values 1 to 9 and above.
                dis_temp = dis_temp - ( result * 10);
                disp_dataw(num[14]);  // print "."
                disp_dataw(num[dis_temp]);    // print tenth of degree
                disp_dataw(0x07);             // print degree symbole.  
                disp_dataw(num[11+ temp_display_mode]); // print F or C.
                } 
            else 
                display(LINE2, message[5]);
            break;                     
        }
}
/*****************************************************************************
Name:         mode_task  
Parameters:                     
Returns:        
Description:  Process key inputs and changes mode and data.    
*****************************************************************************/
void mode_task(void)
{
    key = dequeue_key();
    switch(sys_mode){
        case SET_HR:
            switch(key){
                case KEY_A: // mode change
                          sys_mode = SET_MIN;
                    break;
                case KEY_B:
                    if(cur_hour <= 1) cur_hour = 12;
                    else cur_hour = cur_hour - 1;
                    break;
                case KEY_C:
                    if(cur_hour >= 12) cur_hour = 1;
                    else cur_hour = cur_hour + 1;
                    break;
                }
            break;
        case SET_MIN:
            switch(key){
                case KEY_A: // mode change
                    sys_mode = DIS_TIME_TEMP;
                    set_time( cur_hour, cur_min, cur_sec);		// Function in "rtc.c".
                    disp_ctrlw(LCD_CLEAR);
                    break;
                case KEY_B:
                     if(cur_min <= 0) cur_min = 59;
                     else cur_min = cur_min - 1;
                   break;
                case KEY_C:
                    if(cur_min >= 59)cur_min = 0;
                    else cur_min = cur_min + 1;
                    break;
                }
            break;
	case SET_HEADING:
            switch(key){
                case KEY_A: // mode change
                    change_heading(-1);		 // Function in "compass.c".
		    diplay(1,strHeading);
                   break;
                case KEY_B:
                    sys_mode = DIS_TIME_TEMP;
                   break;
                case KEY_C:
                    if(cur_min >= 59)cur_min = 0;
                    else cur_min = cur_min + 1;
                    break;
                }
            break;
        case DIS_TIME_TEMP:
            switch(key){
                case KEY_A:
                    if(temp_display_mode)
                        temp_display_mode = 0;
                    else
                        temp_display_mode = 1;
                    break;
                case KEY_B: 
			sys_mode= SET_HEADING;
                    break;
                case KEY_C: // Goto set time 
	                DISABLE_INTS
	                t1ic = 0x00; 	// disable interrupt for timer b0. 
	                ENABLE_INTS
                    LED(YEL_LED, OFF);
                    sys_mode = SET_HR;
                    cur_sec = 0;
                    break;
                default:
                    break;
                }
            break;
        default:
            break;
        }

}
/*****************************************************************************
Name:       temp_message_task    
Parameters:                     
Returns:        
Description: Monitors the Main OSC for stop detection.    
*****************************************************************************/
void temp_message_task(void)
{
    if(init_osc_det){
        init_osc_det = 0;
        clock_fault_reset = 0;
 		prc0 = 1;					// Enable writes to Clock control registers.
		cm2 = 0x03;					// Oscillation stop detection enabled.
		prcr = 0x00;				// Inhibit writes to Clock control registers.
        }

    if(cm23){    // main clock osc stopped OSC,
        txck0 = 0;                  // Change clock source for X timer back to "/1".
        LED(GRN_LED, OFF);
        LED(RED_LED, ON);
        if(clock_mode_change == 0){
            clock_mode_change = 1;
            temp_mess_dis_timer = 6;
            current_sys_mode = sys_mode;
            sys_mode = TEMP_MESSAGE;
            display(0, message[2]);
            display(1, message[4]);
            }
        }
    else {           // main clock osc running. 
        txck0 = 1;                  // Change clock source for X timer back to "/8".
        LED(GRN_LED, ON);
        LED(RED_LED, OFF);
        if(clock_fault_reset  == 1){
  			prc0 = 1;					// Enable writes to Clock control registers.
 			cm2 = 0x00;					// Select Xin clock 
 			prcr = 0x00;				// Inhibit writes to Clock control registers.
			init_osc_det = 1;
            }
        else
            if(cm22 == 1) clock_fault_reset = 1;
        if(clock_mode_change == 1){
            clock_mode_change = 0;
            temp_mess_dis_timer = 5;
            current_sys_mode = sys_mode;
            sys_mode = TEMP_MESSAGE;
            display(0, message[2]);
            display(1, message[3]);
            }
        }
     if(temp_mess_dis_timer){
        --temp_mess_dis_timer;
         if(temp_mess_dis_timer == 0) {
            sys_mode = current_sys_mode;
            disp_ctrlw(LCD_CLEAR);
            }
        }



}
/*****************************************************************************
Name:          display_welcome_message 
Parameters:                     
Returns:        
Description:   Displays welcome message. 

*****************************************************************************/
void display_welcome_message(void)
{
const unsigned char welcome[9] = "Welcome!";
const unsigned char banner[44] = "        Welcome to compass tracker        ";
const unsigned char banner2[10] = "  MENUS  ";
const unsigned char banner3[9] = "(c) 2002";
unsigned char  index;
unsigned char display_index;   // values 0 to 8.
ALL_LED_ON
index = 0;
display_index = 0;
disp_ctrlw(LCD_CURSOR_OFF);
disp_ctrlw(LCD_HOME_L1);
while(display_index < 8){
    if (S_S2 == 0)
        goto exit_intro;
    disp_dataw(welcome[display_index]);
    ++display_index;
    tdelay(mSECONDS(175));
    }
disp_ctrlw(LCD_CLEAR);
disp_ctrlw(LCD_CURSOR_OFF);
display_index = 0;
while(index < 42){
    while(display_index < 9){
        if (S_S2 == 0)
            goto exit_intro;
        disp_dataw(banner[index + display_index]);
        ++display_index;
        }
    tdelay(mSECONDS(175));
    disp_ctrlw(LCD_CLEAR);
    display_index = 0;
    ++index;
    }
disp_ctrlw(LCD_CLEAR);
disp_ctrlw(LCD_CURSOR_OFF);
display(0, banner2);
display(1, banner3);
tdelay(mSECONDS(2000));
exit_intro:
while(S_S2 == 0);
disp_ctrlw(LCD_CLEAR);
ALL_LED_OFF
}

/*****************************************************************************
Name:           display_time      
Parameters:     ln --> LCD line number.                     
Returns:        
Description:    display current time on line 0 of 1 of LCD.    

*****************************************************************************/
void display_time(char ln)
{
static unsigned char result;
if(ln == 0)
    result = LCD_HOME_L1;
else 
    result = LCD_HOME_L2; 
disp_ctrlw(result);      // home to line ln
result = cur_hour / 10;  disp_dataw(num[result]);
result = cur_hour - (result * 10); disp_dataw(num[result]);
disp_dataw(num[10]);    // print ":"
result = cur_min / 10; disp_dataw(num[result]);
result = cur_min - (result * 10);  disp_dataw(num[result]);
disp_dataw(num[10]);    // print ":"
result = cur_sec / 10;  disp_dataw(num[result]);
result = cur_sec - (result * 10);  disp_dataw(num[result]);
}
/*****************************************************************************
Name:         AD_sample_task 
Parameters:                     
Returns:        
Description:  Averges the AD samples based on 5 continouse reads.       

*****************************************************************************/
void AD_sample_task(void)
{
unsigned int old_ad_value;
    old_ad_value = avg_ad_value;
    avg_ad_value = (unsigned int)((old_ad_value * 7.0/8.0) + ((ad_value * 10.0)/8)); // Smooth ad reading. 
    adst = 1;               // start next AD conversion. 
}
/*****************************************************************************
Name:        ad_intr_handler   
Parameters:                     
Returns:        
Description:  AD interrupt handler.   

*****************************************************************************/
void ad_intr_handler(void)
{
    ad_value = ad +1;
    adst = 0;
}






